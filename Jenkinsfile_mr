#!groovy

def handleCheckout = {
	if (env.gitlabMergeRequestId) {
		sh "echo 'Merge request detected. Merging...'"
		def credentialsId = scm.userRemoteConfigs[0].credentialsId
		checkout ([
			$class: 'GitSCM',
			branches: [[name: "${env.gitlabSourceNamespace}/${env.gitlabSourceBranch}"]],
			extensions: [
				[$class: 'PruneStaleBranch'],
				[$class: 'CleanCheckout'],
				[
					$class: 'PreBuildMerge',
					options: [
						fastForwardMode: 'NO_FF',
						mergeRemote: env.gitlabTargetNamespace,
						mergeTarget: env.gitlabTargetBranch
					]
				]
			],
userRemoteConfigs: [
[
credentialsId: credentialsId,
name: env.gitlabTargetNamespace,
url: env.gitlabTargetRepoSshURL
],
[
credentialsId: credentialsId,
name: env.gitlabSourceNamespace,
url: env.gitlabSourceRepoSshURL
]
]
		])
	} else {
		sh "echo 'No merge request detected. Checking out current branch'"
		checkout ([
			$class: 'GitSCM',
			branches: scm.branches,
			extensions: [
					[$class: 'PruneStaleBranch'],
					[$class: 'CleanCheckout']
			],
			userRemoteConfigs: scm.userRemoteConfigs
		])
	}
}


node {
    stage('Get Code') {
                		sh "env | sort"
		handleCheckout()
		sh "git branch -vv"
        }
        stage('Create test_venv'){
            sh """
                python3 -m virtualenv ${WORKSPACE}/venv
                echo ${WORKSPACE}/venv
                . ${WORKSPACE}/venv/bin/activate
                pip install -r requirements.txt
                """
        }
        stage('Bandit Testing'){
            sh """
            . ${WORKSPACE}/venv/bin/activate
            pip install bandit
            bandit -r flaskapp/ -f custom -o bandit.out --msg-template "{abspath}:{line}: {severity}: {test_id}: {msg}"
            """
            script {
                def output_list = readFile("bandit.out")
                output_list.size()
                if (output_list.size() != 0) {
                    error("Bandit caught an issue")
                    sh "echo ${output_list}"
                }
            }
        }
          } finally {
        def currentResult = currentBuild.result ?: 'SUCCESS'
        if (currentResult == 'FAILURE') {
            echo 'This will run only if the run was marked as unstable'
        }
        if (currentResult == 'FAILURE') {
            echo 'Success'
        }
        def previousResult = currentBuild.getPreviousBuild()?.result
        if (previousResult != null && previousResult != currentResult) {
            echo 'This will run only if the state of the Pipeline has changed'
            echo 'For example, if the Pipeline was previously failing but is now successful'
        }

        echo 'This will always run'
    }
    }